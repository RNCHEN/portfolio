[
{
		"title": "NPM Theory",
		"date":"Mon Aug 19 2024 21:55:38 GMT-0400 (北美东部夏令时间)",
		"url":"/SDE/2024/npm-theory/",
		"content": "以 https://github.com/bvaughn/js-search 为例子\n\n可以找到\n\n但是另一个react项目中\n会有一些 @开头的东西\n\n这是静态类型检查\nWhen\n什么时候会有\n在使用 npm 安装依赖包时，@types 包会被添加到 node_modules 目录中的几种情况如下：\n1. 明确安装 @types 包\n如果你在安装某个 JavaScript 库的同时，也明确地安装了该库的类型定义包，这个类型定义包（通常是以 @types/ 前缀命名的）会被添加到 node_modules 目录中。例如，如果你安装了 lodash 和它的类型定义：\n\nnpm install lodash\nnpm install --save-dev @types/lodash\n\n这种情况下，@types/lodash 会出现在 node_modules/@types 目录下。\n2. 库内置类型定义\n有些库直接在其自身的 npm 包中包含了 TypeScript 类型定义文件。这些库不需要额外的 @types 包，因为它们的类型定义已经被内置在库的发布版本中。这些类型定义通常在库的 package.json 文件中通过 types 或 typings 字段指定。例如，如果你安装了这样一个库：\n\nnpm install some-library\n\n并且该库内置了类型定义，你不需要安装任何 @types/some-library，类型定义已经随库一起被安装。\n3. 间接依赖\n如果你安装的某个库依赖于其他需要类型定义的库，这些依赖的库的类型定义（如果存在）也可能被自动安装。这取决于你安装的主库如何管理其类型依赖。如果主库在其 package.json 中列出了 @types/ 依赖作为它的依赖之一，那么这些类型定义包也会被安装。\n4. 开发依赖自动安装\n在某些项目配置中，你可能在项目的 package.json 文件中已经包含了一系列开发依赖（包括各种 @types 包），当你运行 npm install 时，所有列出的依赖项都会被安装。\n总结\n@types 类型定义包的安装通常是为了在 TypeScript 项目中提供 JavaScript 库的类型信息，以支持类型检查和其他 TypeScript 功能。安装这些包可以是明确的（直接安装）或间接的（作为依赖或内置在库中）。在日常开发中，正确管理这些类型定义是维护 TypeScript 项目类型安全的重要方面。\n没有的话想有怎么办\n自己写\n有的话想没有怎么办\n1. 使用 any 类型\n最简单的方法是通过声明整个模块为 any 类型来绕过 TypeScript 的类型系统。这种方法非常快速，几乎不需要额外的代码或文件。你可以在项目的一个全局类型声明文件中添加如下内容：\ntypescript复制代码\n// 在一个全局的 d.ts 文件，如 types.d.ts\ndeclare module 'example-library';\n\n这行代码会使得 TypeScript 将 example-library 视为任意类型，从而不会对其内容进行类型检查。这样做的好处是简便，坏处是你失去了类型检查带来的很多好处，比如编码时的自动完成和错误检测。\n2. 配置 TypeScript 编译器选项\n如果你不想在你的项目中特别为某些库编写或维护类型声明，你可以通过修改 tsconfig.json 文件中的编译器选项来减少类型错误：\njson复制代码\n{\n&quot;compilerOptions&quot;: {\n&quot;skipLibCheck&quot;: true,\n&quot;noImplicitAny&quot;: false}\n}\n\nskipLibCheck: 这个选项会让 TypeScript 编译器忽略所有第三方库文件（.d.ts 文件）的类型检查错误。这对于快速绕过错误的类型定义文件非常有用。\nnoImplicitAny: 设置为 false 可以允许 TypeScript 将没有明确指定类型的表达式和声明隐式地视为 any 类型，这减少了显式声明 any 的需要。\n\n3. 评估是否更换库\n如果一个库因为缺乏类型支持而导致在 TypeScript 项目中使用时遇到持续的问题，也可以考虑是否有其他更好的替代库，这些库可能已经有良好的 TypeScript 支持。选择一个社区支持更强、更新更频繁、内置类型声明的库，可能会减少很多开发中的麻烦。\nWhy\n为什么会有 = 有什么好处\n引入类型检查，特别是在使用如 TypeScript 这样的静态类型语言时，可以带来多个明显的好处。下面我将解释为什么要加类型检查，并通过代码示例来展示这些好处。\n为什么需要类型检查\n\n错误减少：类型检查可以在编译阶段捕捉错误，如类型不匹配、未定义的函数调用、参数错误等。这意味着很多潜在的运行时错误可以在代码运行前就被发现和解决。\n代码质量提升：类型系统强制开发者在写代码时就思考数据的类型和结构，这促使开发者更深入地思考问题，从而写出更清晰和更可维护的代码。\n自动化文档：类型定义本身就起到了文档的作用，明确地展示了函数期望的输入和输出。这使得代码更易于理解和使用，尤其是在团队协作中。\n智能的代码补全：大多数支持 TypeScript 的开发环境（如 Visual Studio Code）提供了基于类型信息的智能代码补全、导航和重构工具，大大提高了开发效率。\n\n代码示例\n假设我们有一个简单的 JavaScript 函数，用于处理用户信息，如果没有类型检查，可能写成这样：\nfunction handleUserInfo(user) {\nconsole.log(&quot;User Name: &quot; + user.name);\nconsole.log(&quot;User Age: &quot; + user.age);\n}\n\n// 调用函数 不会报错\nhandleUserInfo({ name: &quot;Alice&quot;, age: &quot;25&quot; });\n\n在上面的 JavaScript 代码中，age 字段被错误地传入了一个字符串，而我们期望的是一个数字。这种错误在 JavaScript 中很常见，因为它是动态类型语言。\n在这段代码中，由于 age 传入了一个字符串 &quot;25&quot; 而不是数字，以下是可能的情况和影响：\n1. 输出\n在当前的函数实现中，age 被作为字符串处理并直接连接到另一个字符串，所以这个错误不会直接导致程序崩溃或者明显的运行时错误。输出将会是：\nsql复制代码\nUser Name: Alice\nUser Age: 25\n\n这看起来可能并没有什么问题，但这并不意味着数据是正确处理的。\n2. 后续数值操作的影响\n如果程序的其他部分期望 age 是一个数字，并在此基础上进行数值计算，比如计算年龄区间或者验证年龄是否在某个范围内，使用字符串就可能导致错误或不预期的行为。例如：\njavascript复制代码\nif (user.age &lt; 30) {\nconsole.log(&quot;Under 30 years old.&quot;);\n} else {\nconsole.log(&quot;30 years or older.&quot;);\n}\n\n在 JavaScript 中，尝试对字符串和数字进行比较会导致 JavaScript 尝试将字符串转换为数字。在这种情况下，由于 &quot;25&quot; 是一个有效的数字字符串，它会被转换为数字 25，并正确地进行比较。但如果字符串不是有效的数字（如 &quot;twenty-five&quot;），则比较的结果会是 NaN (Not a Number)，这会使得条件判断失败，导致逻辑上的错误。\n现在，我们用 TypeScript 来改写上述代码，并加入类型检查：\ninterface User {\nname: string;\nage: number;\n}\n\nfunction handleUserInfo(user: User) {\nconsole.log(&quot;User Name: &quot; + user.name);\nconsole.log(&quot;User Age: &quot; + user.age);\n}\n// 尝试调用函数\nhandleUserInfo({ name: &quot;Alice&quot;, age: &quot;25&quot; }); // TypeScript 会在这里报错\n\n在 TypeScript 版本中，我们定义了一个 User 接口来指定 user 参数的结构，包括类型信息。如果尝试像之前那样错误地传递一个字符串作为年龄，TypeScript 编译器将会在编译时抛出错误，提示我们 age 的类型不匹配。这样的类型检查可以防止我们在代码进一步执行之前犯下可能导致运行时错误的低级错误。\nwebpack\n如果想要查看源码的问题的话\n\n&quot;require&quot;: &quot;./dist/umd/js-search.js&quot;：如果包是通过 require()（即 CommonJS 方式）被导入，那么将使用 ./dist/umd/js-search.js。\n&quot;import&quot;: &quot;./dist/esm/js-search.js&quot;：如果包是通过 ES6 import 语句被导入，那么将使用 ./dist/esm/js-search.js。\n\nrequire和 import的区别是什么\n语法\n\nrequire()：\n\nCommonJS 模块使用 require() 函数来加载模块。\n语法较为简单，主要用在 Node.js 中。\n示例：const lodash = require('lodash');\n\nimport：\n\nES6 模块使用 import 语句来导入模块。\n支持更复杂的导入方式，如导入单个函数、多个函数、或重命名。\n示例：import { map, reduce } from 'lodash'; 或 import * as lodash from 'lodash';",
		"tags": [ "note"]
},

{
		"title": "High Concurrency",
		"date":"Mon Aug 19 2024 21:55:38 GMT-0400 (北美东部夏令时间)",
		"url":"/SDE/2024/high-concurrenct/",
		"content": "NODEJS\nNode.js 使用单线程事件循环和非阻塞 I/O 模型。所有 I/O 操作（如文件读写、网络请求等）都是异步的，不会阻塞主线程。事件循环机制使得 Node.js 能够高效地处理大量并发请求\n\n尽可能的返回 暂时没有看这个代码\n\nfunction handleResult(index, result, resultsArray, resolve, allPromisesCount) {\nresultsArray[index] = result; // 将结果保存到对应的位置\n// 检查是否所有结果都已经完成\nif (resultsArray.every(item =&gt; item !== undefined)) {\nresolve(resultsArray); // 如果所有Promise都完成，则解决最终的Promise\n}\n}\n\nfunction handleAllPromises(promises) {\nreturn new Promise(resolve =&gt; {\nconst results = new Array(promises.length); // 创建一个数组来存储结果\npromises.forEach((promise, index) =&gt; {\npromise.then(result =&gt; {\nconsole.log(`Promise ${index + 1} resolved with:`, result);\nhandleResult(index, result, results, resolve, promises.length);\n}).catch(error =&gt; {\nconsole.error(`Promise ${index + 1} failed with:`, error);\nhandleResult(index, { error: true, message: error }, results, resolve, promises.length);\n});\n});\n});\n}\n\n// 示例使用\nconst promise1 = Promise.resolve(42);\nconst promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, '失败'));\nconst promise3 = new Promise((resolve) =&gt; setTimeout(resolve, 200, '成功'));\n\nhandleAllPromises([promise1, promise2, promise3])\n.then(allResults =&gt; {\nconsole.log('All promises are completed:', allResults);\n});\n\nJava\n\n多线程编程：\n\nJava 提供了强大的多线程支持，开发者可以通过创建线程或使用线程池来处理并发任务。Java 的 java.util.concurrent 包提供了丰富的并发工具类，如 Executor 框架、并发集合等。\n\n非阻塞 I/O (NIO)：\n\nJava NIO 提供了非阻塞 I/O 操作，可以在一个线程中处理多个 I/O 操作，避免了传统阻塞 I/O 的性能瓶颈。NIO 包含了选择器（Selector）、通道（Channel）和缓冲区（Buffer）等组件\n\nGo\n阻塞I/O\n\nJava：\n\n传统的Java IO API（如java.io包）默认使用阻塞IO。\nJava的Socket和ServerSocket类默认也是阻塞的。\n\nPython：\n\nPython的标准库中的大多数IO操作默认是阻塞的。\n例如，open()函数打开的文件对象、socket模块的基本操作等\n\nC：\n\nC语言的标准IO库（如fread(), fwrite()）默认是阻塞的。\n系统调用如read()和write()在默认情况下也是阻塞的。\n\nadvantage of Blocking IO\n非阻塞和异步是一个东西吗\n同步异步 阻塞和非阻塞\nhttps://juejin.cn/post/6844903683583377416?searchId=202408020617186FF13CCF5F52FAC4972C\n阻塞、非阻塞说的是调用者，同步、异步说的是被调用者\n同步 非阻塞 ？\nCallback 和原有函数的执行顺序问题\ncallback由谁来执行\n是由主线程执行 还是 greet执行呢 =&gt; JS是单线程语言\nfunction greet() {\nconsole.log('Hello, world!');\n}\nconsole.log('This message will be displayed first.');\n\nsetTimeout(greet, 2000);\n\nconsole.log('This message will be displayed second.');\n\nfunction downloadFile(url, callback) {\nconsole.log(&quot;Starting the download from:&quot;, url);\nsetTimeout(() =&gt; { // 模拟异步的文件下载操作\nconst downloadedData = &quot;Some data from &quot; + url; // 假设的下载数据\ncallback(downloadedData); // 调用回调函数处理下载的数据\n}, 2000);\nconsole.log(&quot;end??&quot;)\nunction processData(data) {\nconsole.log(&quot;Processing data:&quot;, data);\n}\n\ndownloadFile(&quot;http://example.com/file&quot;, processData);\n\n变量的作用域\nfor (let i = 0; i &lt; 3; i++) {\n  console.log(i);\nsetTimeout(function() {\nconsole.log(i); // 每个 setTimeout 引用的都是不同的 'i' 实例\n}, 100 * i);\n}\n// 输出: 0 1 2 0, 1, 2 （每个输出间隔 100ms）\n\nfor (var i = 0; i &lt; 3; i++) {\n            console.log(i);\nsetTimeout(function() {\nconsole.log(i); // 所有的 setTimeout 引用的都是同一个 'i'\n}, 100 * i);\n}\n// 输出: 0 1 2 3, 3, 3 （每个输出间隔 100ms）",
		"tags": [ "note"]
},

{
		"title": "Jeffrey Chen's Resume",
		"date":"Mon Aug 19 2024 21:55:38 GMT-0400 (北美东部夏令时间)",
		"url":"/",
		"content": "JEFFREY CHEN\n412-390-7892 | weigenc@andrew.cmu.edu\nGitHub | LinkedIn\n\nEDUCATION\nCarnegie Mellon University, Pittsburgh, PA\nMaster of Science in Electrical and Computer Engineering (3.8/4)\nExpected May 2025\nUniversity of Electronic Science and Technology of China, Chengdu, China\nBachelor of Science in Software Engineering (3.88/4)\nSeptember 2019 - June 2023\n\nSKILLS\nProgramming Languages: Java, Go, Python, SQL, JavaScript, TypeScript, Rust, C, Bash, R\nFrameworks &amp; Databases: MySQL, MongoDB, Redis, Elasticsearch, Spring, Django, Fiber, Node.js, React, Next.js\nCloud &amp; Tools: AWS, Spark, SAP Hana, Hadoop, GCP, Docker, Kubernetes, Nginx, Jenkins, CI/CD, GraphQL\n\nWORKING EXPERIENCE\nCepton, San Jose, CA\nSoftware Engineer Intern\nMay 2024 - August 2024\n\nRefactored an internal developer website from React to Next.js, employing a Static Site Generator to enhance First Contentful Paint times by 40% and integrating CDN to reduce server load.\nReplaced a C++ test system with Rust to enhance memory safety, concurrency handling, and maintainability.\nEnhanced system reliability and data integrity through a validation-first approach, enabling concurrent downloading.\nEstablished a CI/CD pipeline utilizing Docker, Jenkins, and GitHub Actions to accelerate release cycles by 20%.\n\nCarnegie Mellon University - Software and Societal Systems Department, Pittsburgh, PA\nSoftware Engineer Developer\nJanuary 2024 - May 2024\n\nDeveloped a high-performance data collection system leveraging Fiber for optimal CPU core utilization and reduced memory leakage, enhanced with MongoDB using indexed data storage for performance optimization.\nEnhanced response efficiency by 70% by switching from RESTful to GraphQL API, optimizing data retrieval processes.\nImplemented browser storage, skeleton screens, and lazy loading in React to enhance user experience by reducing load times and providing seamless visual feedback.\n\nSAP, Chengdu, China\nSoftware Engineer Intern\nSeptember 2022 - April 2023\n\nLed the migration of employment timesheet selection feature to a Node.js API service for batching processing and asynchronous computations, optimizing the response time by 80% and significantly enhancing user experience.\nIntroduced an authentication mechanism for private data upload using CSRF token, ensuring encryption in transit.\nRefactored the time-tracking API service on S4 HANA by migrating from a row-based to a columnar database architecture, resulting in a 10% increase in response speed.\n\nData Dream Technology Company, Hangzhou, China\nSoftware Engineer Intern\nFebruary 2022 - August 2022\n\nConstructed a secure rental system with integrated authentications using Spring Security, React, OAuth2.0, and JWT. Adhered to Agile methodologies throughout the software development life cycle.\nApplied lazy loading and advanced pagination, enhancing the user experience and system performance by 25%.\nIntroduced a Redis cache for news metadata search results, reducing search time by 46%.\n\nPROJECTS\nETL Optimization and Kubernetes Scheduling\nMarch 2024 - April 2024\n\nDeveloped a distributed machine learning pipeline for LLM inference using Apache Spark, deployed on AWS, to handle a complex 60GB dataset with over 800 million features, utilizing HDFS for scalable data management.\nAdvanced data handling by implementing an inverted index and optimizing joins in RDDs to reduce data shuffling, solving OOM issues and cutting gradient descent training time by 60%.\nImplemented an advanced Kubernetes scheduler for managing both CPU and GPU machines, optimizing resource allocation for MPI and ML jobs, reducing Job Completion Time by 60%.\n\nHigh-Performance Proxy Server\nFebruary 2024 - March 2024\n\nImplemented a multi-threaded, cache-designed proxy server in C using mutexes, read-write locks, and producer-consumer synchronization to ensure data consistency in high-concurrency environments.\nEngineered a cache simulator to store web response objects, using LRU replacement policy and following a write-back, write allocate policy, boosting proxy server throughput by 30%.",
		"tags": [ "note","gardenEntry"]
}
]